version: "3.8"

services:
  # --- 1. Bases de Datos ---
  auth-db:
    image: mysql:8.0
    container_name: auth-db
    environment:
      MYSQL_ROOT_PASSWORD: ${AUTH_DB_ROOT_PASSWORD} 
      MYSQL_DATABASE: auth_transafe
    ports:
      - "3308:3306" # Expones la BD para debugging, está bien
    volumes:
      - auth-db-data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${AUTH_DB_ROOT_PASSWORD}"]
      interval: 10s
      timeout: 5s
      retries: 5

  trans-db:
    image: mysql:8.0
    container_name: trans-db
    environment:
      MYSQL_ROOT_PASSWORD: ${TRANS_DB_ROOT_PASSWORD}
      MYSQL_DATABASE: transaccion_transafe
    ports:
      - "3307:3306" # Expones la BD para debugging, está bien
    volumes:
      - trans-db-data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${TRANS_DB_ROOT_PASSWORD}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # --- 2. Broker de Mensajería ---
  rabbitmq:
      image: rabbitmq:3-management
      container_name: rabbitmq
      ports:
        - "5672:5672"
        - "15672:15672"
      healthcheck:
        # CAMBIO: Usamos 'rabbitmq-diagnostics check_port_connectivity'
        # Esto SÍ garantiza que el puerto de conexión está listo.
        test: rabbitmq-diagnostics -q check_port_connectivity
        interval: 10s
        timeout: 5s
        retries: 10 # Le damos más reintentos
        start_period: 20s # Le damos 20s para que arranque antes de chequear

  # --- 3. Microservicios de Backend ---
  
  # ===============================================
  # === ¡NUEVO SERVICIO! - API GATEWAY ===
  # ===============================================
  gateway:
    build:
      # Asumimos que pones el gateway en esta ruta
      context: ./backend/services/gateway
      dockerfile: DockerFile
    container_name: gateway_service
    ports:
      # Este es AHORA el ÚNICO punto de entrada a tu API
      - "80:7000" 
    depends_on:
      # El Gateway no puede arrancar hasta que los servicios
      # que llama estén listos
      auth_service:
        condition: service_started
      transactions_service:
        condition: service_started
  # ===============================================

  auth_service:
    build:
      context: ./backend/services/auth
      dockerfile: DockerFile
    container_name: auth_service
    env_file: ./backend/services/auth/.env
    environment:
      - SECRET_KEY=${SECRET_KEY}
      - ALGORITHM=${ALGORITHM}
      - AUTH_DB_ROOT_PASSWORD=${AUTH_DB_ROOT_PASSWORD}
    # ¡PUERTO ELIMINADO!
    # 'ports: - "8000:8000"' <--- Se elimina
    # Ahora solo el Gateway accede a este servicio
    # internamente en el puerto 8000 (que expone el Dockerfile)
    depends_on:
      auth-db:
        condition: service_healthy

  transactions_service:
    build:
      context: ./backend/services/transacciones
      dockerfile: DockerFile
    container_name: transactions_service
    env_file: ./backend/services/transacciones/.env
    environment:
      - SECRET_KEY=${SECRET_KEY}
      - ALGORITHM=${ALGORITHM}
      - TRANS_DB_ROOT_PASSWORD=${TRANS_DB_ROOT_PASSWORD}
    # ¡PUERTO ELIMINADO!
    # 'ports: - "8001:8001"' <--- Se elimina
    # Ahora solo el Gateway (y el fraud_service) acceden
    # a este servicio internamente.
    volumes:
      - ./backend/services/transacciones:/app
    depends_on:
      trans-db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy

  fraud_service:
    build:
      context: ./backend/services/fraud_service
      dockerfile: DockerFile
    container_name: fraud_service
    env_file: ./backend/services/fraud_service/.env
    volumes:
      - ./backend/services/fraud_service:/app
    depends_on:
      rabbitmq:
        condition: service_healthy
      transactions_service:
        condition: service_started

# --- Volúmenes ---
volumes:
  auth-db-data:
  trans-db-data: